# 面试题
#### 1、python 协程和 go 协程 的区别？  
答: python: 协程有传染性，即只要有阻塞的地方必须使用协程;只能使用一个cpu
    go:可以很轻松的创建一个协程；协程可以使用多个cpu，达到真正的并行。 
#### 2、什么是go 变量逃逸分析？  
#### 3、服务器上内存泄漏如何追踪？  
#### 4、go channel 为什么是线程安全的？  
#### 5、redis 数据类型有哪些？  
答：redis支持五种数据类型:string(字符串),hash(哈希),list(列表),set(集合),zset(有序集合)  
#### 6、webpack的打包模式有哪些？  
答：分三种：none/development/production  
#### 7、进程、线程、协程的区别？  
答：  ①进程 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。  
②线程
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。    
③协程
协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快

进程与线程区别  
① 地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间  
② 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源  
③ 线程是处理器调度的基本单位,但进程不是  
④ 二者均可并发执行  
线程和协程区别  
①数据存储：线程是内核态的内存空间；协程一般是用户态的内存空间  
②切换操作：线程操作最终在内核层完成，应用层需要调用内核层提供的syscall底层函数；协程应用层使用代码进行简单的现场保存和恢复即可  
③任务调度：由内核实现，抢占方式；协程由用户态的实现具体调度器进行  
#### 8、什么是悲观锁、乐观锁 ?
答：悲观锁：当要对数据库中的一条数据进行修改时，为了防止并发修改而对该数据在修改前加锁，修改后释放锁的机制成为悲观锁。  
乐观锁：不通过数据库自带的锁机制，采用字段检测（如版本号）是否更新的方式称为乐观锁，乐观锁适用于读操作多的场景，这样可以提高程序的吞吐量  
#### 9、什么是脏读、幻读、不可重复读？
答：脏读又称无效数据读出（读出了脏数据）。一个事务读取另外一个事务还没有提交的数据叫脏读。

例如：事务T1修改了某个表中的一行数据，但是还没有提交，这时候事务T2读取了被事务T1修改后的数据，之后事务T1因为某种原因回滚（Rollback）了，那么事务T2读取的数据就是脏的（无效的）。

解决办法：把数据库的事务隔离级别调整到READ_COMMITTED（读提交/不可重复读）  
幻读也是指当事务不独立执行时，插入或者删除另一个事务当前影响的数据而发生的一种类似幻觉的现象。

例如：系统事务A将数据库中所有数据都删除的时候，但是事务B就在这个时候新插入了一条记录，当事务A删除结束后发现还有一条数据，就好像发生了幻觉一样。这就叫幻读。

解决办法：把数据库的事务隔离级别调整到SERIALIZABLE_READ（序列化执行），或者数据库使用者自己进行加锁来保证。  
不可重复读是指在同一个事务内，两次相同的查询返回了不同的结果。

例如：事务T1会读取两次数据，在第一次读取某一条数据后，事务T2修改了该数据并提交了事务，T1此时再次读取该数据，两次读取便得到了不同的结果。  
解决办法：把数据库的事务隔离级别调整到REPEATABLE_READ（可重复读）
#### 10、数据库创建外键的优缺点？  
#### 11、有哪些优化数据库的手段？  
#### 12、什么是索引？有哪些索引类别？  
答：在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构。索引有：单列索引、唯一索引、主键索引和聚集索引
#### 13、索引创建的优缺点？  
答：优点：①加快数据的检索速度、②加快表与表之间的连接，实现数据的完整性、③加快分组和排序子句的检索时间   
缺点：①消耗物理空间，索引本身也是表②对表的数据增加、删除、修改时，索引也需要动态维护
#### 14、python 生成器是什么？生成器和迭代器的区别？  
#### 15、什么是视图？  
答：视图是一个虚拟表，其内容由查询定义  
#### 16、django 发起请求的过程？
答：浏览器发起请求->请求到达request中间件，中间件对请求做预处理或者直接返回response->若未返回response，会到达urlconf路由->process_view中间件->view中的方法->response中间件->客户端  
#### 17、content-type有哪些？通过表单发起登陆请求是哪个格式？
答：常见的有:1、text/html html格式 2、text/plain 纯文本格式 3 text/xml XML格式 4、application/xml XML数据格式 5、application/json JSON数据格式 6、application/octet-stream 二进制流数据（如常见的文件下载） 7、application/x-www-form-urlencoded 常见表单格式 8、multipart/form-data  需要在表单中进行文件上传时，就需要使用该格式  
表单发起登陆采用application/x-www-form-urlencoded 
#### 18、什么是最左前缀原则？  
#### 19、JWT是什么？和传统的session认证有什么区别？
答：Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。  
区别：传统的session认证通过二级域名共享cookies，无法做到跨域实现单点登陆，jwt可以实现跨域分布式单点登陆  
#### 20、go 的gc回收是怎么样的？
答：go回收采用三色标记法。①首先创建三个集合：白、灰、黑② 将所有对象放入白色集合③从根节点开始遍历所有对象，把遍历到的对象从白色集合放入灰色集合④之后遍历灰色集合，将灰色对象的引用的对象从白色集合移动到灰色集合，之后把所有灰色集合移动到黑色集合⑤重复4直到灰色集合无任何对象⑥收集所有白色对象
#### 21、celery如果报错了需要怎么处理？
#### 22、websocket报错后如何处理？
#### 23、python和go 内存管理是怎么样的？
答：python 一切皆对象的理念，所有的对象都存放在堆内存，内存的管理由python 内部的gc回收,用户不需要特别管理。python的gc回收包括：引用计数、标记清除、分代回收。  
go go内存包括静态内存、动态内存,动态内存又分为堆内存和栈内存，栈内存由系统自己管理,。堆内存则使用gc回收,go的gc回收包括:三色标记法。特别的,go会为内存做变量逃逸分析，会自动的将栈内存移动到堆内存当中（例如在函数中返回局部变量的地址）
#### 24、redis持久化？
#### 25、mysql主从？
#### 26、状态码502怎么排查？
#### 27、https建立过程？
答：①客户端访问https连接②服务端发送证书（公钥）给客户端③客户端验证服务端的证书④服务端接受加密信息，解密得到客户端提供的随机字符串⑤客户端验证服务端返回的握手信息，完成握手，此后建立连接
#### 28、tcp三次握手过程？
答：①客户端发出请求报文，SYN=1,seq=x ②服务端收到报文后向客户端发送确认,SYN=1,ACK=1,ack=x+1 ③ 客户端向服务端发出确认，ACK=1,seq=x+1,ack=y+1  
#### 29、为什么三次握手？
答：为了防止已失效的连接请求报文段突然又送到了服务端
#### 30、四次挥手后在TIME-WAIT状态必须等待2MSL时间？
答：①为了保证A发送的最后一个ACK报文段能够到达B②防止已失效的连接请求报文段出现在本链接中  
#### 31、mysql采用b+树的原因？
答：①b+树树高小于二叉树，b+树每一层等于物理内存中的一页，每次io都把所有数据读取出来，从而减少了访问io的次数。②叶子节点是一个单链表，在使用范围 between 、in等语句时速度很快